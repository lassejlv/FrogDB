// @bun
var FrogFieldType;(function(FrogFieldType2){FrogFieldType2["String"]="string";FrogFieldType2["Number"]="number";FrogFieldType2["Boolean"]="boolean"})(FrogFieldType||(FrogFieldType={}));import crypto from"crypto";import fs from"fs";var CreateDocumentId=function(){return crypto.randomUUID()};async function Schema(data){const find=async(query)=>{const schemaPath=`./db/${data.name}`;const files=fs.readdirSync(schemaPath).filter((file)=>file.endsWith(".json"));const results=[];for(const file of files){const content=fs.readFileSync(`${schemaPath}/${file}`,"utf-8");const obj=JSON.parse(content);let found=true;for(const key in query){if(obj[key]!==query[key]){found=false;break}}if(found){results.push(obj)}}return results};const insert=async(document)=>{const id=CreateDocumentId();const schemaPath=`./db/${data.name}`;const constructedDocument={id,...document};for(const key in constructedDocument){if(key==="id")continue;if(!data.fields.find((field)=>field.name===key)){throw new Error(`Field ${key} is not in the schema`)}}for(const field of data.fields){if(typeof constructedDocument[field.name]!==field.type){throw new Error(`Field ${field.name} must be of type ${field.type}`)}}fs.writeFileSync(`${schemaPath}/${id}.json`,JSON.stringify(constructedDocument,null,2));return constructedDocument};const findOne=async(query)=>{const results=await find(query);return results[0]};const deleteOne=async(id)=>{const exist=await findOne({id});if(!exist){throw new Error("Document not found")}const schemaPath=`./db/${data.name}`;fs.unlinkSync(`${schemaPath}/${id}.json`);return exist};const deleteAll=async(query)=>{const results=await find(query);for(const result of results){await deleteOne(result.id)}return results};const update=async(id,document)=>{const exist=await findOne({id});if(!exist){throw new Error("Document not found")}const schemaPath=`./db/${data.name}`;const constructedDocument={id,...document};for(const key in constructedDocument){if(key==="id")continue;if(!data.fields.find((field)=>field.name===key)){throw new Error(`Field ${key} is not in the schema`)}}for(const field of data.fields){if(typeof constructedDocument[field.name]!==field.type){throw new Error(`Field ${field.name} must be of type ${field.type}`)}}fs.writeFileSync(`${schemaPath}/${id}.json`,JSON.stringify(constructedDocument,null,2));return constructedDocument};return{...data,find,insert,findOne,deleteOne,deleteAll,update}}function FrogDB(){let path="./db";return{async generate(schemas){const db={};if(!fs.existsSync(path)){fs.mkdirSync(path)}for(const schema of schemas){const schemaPath=`${path}/${schema.name}`;if(schema.fields.find((field)=>field.name==="id")){throw new Error("Schema cannot have a field named 'id'")}if(!fs.existsSync(schemaPath)){fs.mkdirSync(schemaPath)}}return db}}}export{Schema,FrogFieldType,FrogDB};
