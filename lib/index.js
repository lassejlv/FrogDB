// @bun
var FrogFieldType;(function(FrogFieldType2){FrogFieldType2["String"]="string";FrogFieldType2["Number"]="number";FrogFieldType2["Boolean"]="boolean"})(FrogFieldType||(FrogFieldType={}));var formatType=(field)=>{if(field.type===FrogFieldType.String){return"string"}else if(field.type===FrogFieldType.Number){return"number"}else if(field.type===FrogFieldType.Boolean){return"boolean"}else{return"any"}};import crypto from"crypto";import fs from"fs";var CreateDocumentId=function(){return crypto.randomUUID()};async function Schema(data){const find=async(query)=>{const schemaPath=`./db/${data.name}`;const files=fs.readdirSync(schemaPath).filter((file)=>file.endsWith(".json"));const results=[];for(const file of files){const content=fs.readFileSync(`${schemaPath}/${file}`,"utf-8");const obj=JSON.parse(content);let found=true;for(const key in query){if(obj[key]!==query[key]){found=false;break}}if(found){results.push(obj)}}return results};const insert=async(document)=>{const id=CreateDocumentId();const schemaPath=`./db/${data.name}`;const constructedDocument={id,...document};for(const key in constructedDocument){if(key==="id")continue;if(!data.fields.find((field)=>field.name===key)){throw new Error(`Field ${key} is not in the schema`)}if(data.fields.find((field)=>field.name===key&&field.required)&&!constructedDocument[key]){throw new Error(`Field ${key} is required`)}}for(const field of data.fields){if(typeof constructedDocument[field.name]!==field.type){throw new Error(`Field ${field.name} must be of type ${field.type}`)}}fs.writeFileSync(`${schemaPath}/${id}.json`,JSON.stringify(constructedDocument,null,2));return constructedDocument};const findOne=async(query)=>{const results=await find(query);return results[0]};const deleteOne=async(id)=>{const exist=await findOne({id});if(!exist){throw new Error("Document not found")}const schemaPath=`./db/${data.name}`;fs.unlinkSync(`${schemaPath}/${id}.json`);return exist};const deleteAll=async(query)=>{const results=await find(query);for(const result of results){await deleteOne(result.id)}return results};const update=async(id,document)=>{const exist=await findOne({id});if(!exist){throw new Error("Document not found")}const schemaPath=`./db/${data.name}`;const constructedDocument={id,...document};for(const key in constructedDocument){if(key==="id")continue;if(!data.fields.find((field)=>field.name===key)){throw new Error(`Field ${key} is not in the schema`)}}for(const field of data.fields){if(typeof constructedDocument[field.name]!==field.type){throw new Error(`Field ${field.name} must be of type ${field.type}`)}}fs.writeFileSync(`${schemaPath}/${id}.json`,JSON.stringify(constructedDocument,null,2));return constructedDocument};return{...data,find,insert,findOne,deleteOne,deleteAll,update}}function FrogDB(){let path="./db";return{async generate(schemas){const db={};if(!fs.existsSync(path)){fs.mkdirSync(path)}for(const schema of schemas){const schemaPath=`${path}/${schema.name}`;if(schema.fields.find((field)=>field.name==="id")){throw new Error("Schema cannot have a field named 'id'")}const fieldNames=schema.fields.map((field)=>field.name);const uniqueFieldNames=new Set(fieldNames);if(fieldNames.length!==uniqueFieldNames.size){throw new Error("Fields must be unique")}const types3=[];for(const field of schema.fields){types3.push(`${field.name}: ${formatType(field)};`)}if(!fs.existsSync(`${path}/types`)){fs.mkdirSync(`${path}/types`)}const typesPath=`${path}/types/${schema.name}.ts`;fs.writeFileSync(typesPath,`export type ${schema.name} = { id: string; ${types3.join(" ")} };`);if(!fs.existsSync(schemaPath)){fs.mkdirSync(schemaPath)}}return db}}}export{formatType,Schema,FrogFieldType,FrogDB};
